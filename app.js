function efficientBacktrackMoves(path, start, end) {
    // Find the indices of the start and end positions in the path
    let startIndex = path.length - 1;
    let endIndex = path.findIndex(p => p[0] === end[0] && p[1] === end[1]);

    // If start or end position not found in path, or start comes before end
    if (startIndex === -1 || endIndex === -1 || startIndex < endIndex) {
        return [];
    }

    // Extract the sub-path and remove redundant steps
    let subPath = path.slice(endIndex, startIndex + 1).reverse();
    let optimizedPath = [];
    for (let i = 0; i < subPath.length; i++) {
        // Add the last point without checking
        if (i === subPath.length - 1) {
            optimizedPath.push(subPath[i]);
            break;
        }

        // Check if the next point is in a different direction
        let current = subPath[i];
        let next = subPath[i + 1];
        if (current[0] !== next[0] || current[1] !== next[1]) {
            optimizedPath.push(current);
        }
    }

    // Generate moves by backtracking from start to end
    let moves = [];
    for (let i = 0; i < optimizedPath.length - 1; i++) {
        let fromPos = optimizedPath[i];
        let toPos = optimizedPath[i + 1];
        let xDiff = toPos[0] - fromPos[0];
        let yDiff = toPos[1] - fromPos[1];

        if (xDiff > 0) {
            moves.push('right');
        } else if (xDiff < 0) {
            moves.push('left');
        }

        if (yDiff > 0) {
            moves.push('up');
        } else if (yDiff < 0) {
            moves.push('down');
        }
    }

    let fixedMoves = [];
    for (let i = 0; i < moves.length - 1; i++) {
        switch (moves[i]) {
            case 'up':
                if (moves[i + 1] === 'down') {
                    i++;
                } else {
                    fixedMoves.push(moves[i]);
                }
                break;
            case 'down':
                if (moves[i + 1] === 'up') {
                    i++;
                } else {
                    fixedMoves.push(moves[i]);
                }
                break;
            case 'left':
                if (moves[i + 1] === 'right') {
                    i++;
                } else {
                    fixedMoves.push(moves[i]);
                }
                break;
            case 'right':
                if (moves[i + 1] === 'left') {
                    i++;
                } else {
                    fixedMoves.push(moves[i]);
                }
                break;
            default:
                break;
        }
    }

    //append the last move, since it doesn't get processed by the previopus loop bc its checking i+1
    fixedMoves.push(moves[moves.length-1]);

    return fixedMoves;
}
let path = [
    [
      0,
      0,
    ],
    [
      -1,
      0,
    ],
    [
      -1,
      1,
    ],
    [
      -2,
      1,
    ],
    [
      -3,
      1,
    ],
    [
      -4,
      1,
    ],
    [
      -5,
      1,
    ],
    [
      -5,
      0,
    ],
    [
      -6,
      0,
    ],
    [
      -7,
      0,
    ],
    [
      -8,
      0,
    ],
    [
      -9,
      0,
    ],
    [
      -10,
      0,
    ],
    [
      -10,
      1,
    ],
    [
      -9,
      1,
    ],
    [
      -9,
      2,
    ],
    [
      -9,
      3,
    ],
    [
      -9,
      4,
    ],
    [
      -10,
      4,
    ],
    [
      -10,
      5,
    ],
    [
      -9,
      5,
    ],
    [
      -9,
      6,
    ],
    [
      -8,
      6,
    ],
    [
      -7,
      6,
    ],
    [
      -6,
      6,
    ],
    [
      -6,
      5,
    ],
    [
      -7,
      5,
    ],
    [
      -8,
      5,
    ],
    [
      -8,
      4,
    ],
    [
      -7,
      4,
    ],
    [
      -6,
      4,
    ],
    [
      -5,
      4,
    ],
    [
      -5,
      5,
    ],
    [
      -4,
      5,
    ],
    [
      -4,
      6,
    ],
    [
      -3,
      6,
    ],
    [
      -3,
      5,
    ],
    [
      -2,
      5,
    ],
    [
      -1,
      5,
    ],
    [
      -1,
      6,
    ],
    [
      0,
      6,
    ],
    [
      1,
      6,
    ],
    [
      2,
      6,
    ],
    [
      3,
      6,
    ],
    [
      4,
      6,
    ],
    [
      5,
      6,
    ],
    [
      5,
      5,
    ],
    [
      5,
      4,
    ],
    [
      4,
      4,
    ],
    [
      4,
      3,
    ],
    [
      3,
      3,
    ],
    [
      2,
      3,
    ],
    [
      1,
      3,
    ],
    [
      1,
      4,
    ],
    [
      0,
      4,
    ],
    [
      -1,
      4,
    ],
    [
      -2,
      4,
    ],
    [
      -2,
      3,
    ],
    [
      -3,
      3,
    ],
    [
      -3,
      2,
    ],
    [
      -4,
      2,
    ],
    [
      -3,
      2,
    ],
    [
      -2,
      2,
    ],
    [
      -1,
      2,
    ],
    [
      -1,
      3,
    ],
    [
      -1,
      2,
    ],
    [
      0,
      2,
    ],
    [
      1,
      2,
    ],
    [
      2,
      2,
    ],
    [
      2,
      1,
    ],
    [
      1,
      1,
    ],
    [
      0,
      1,
    ],
    [
      1,
      1,
    ],
    [
      1,
      0,
    ],
    [
      2,
      0,
    ],
    [
      2,
      -1,
    ],
    [
      1,
      -1,
    ],
    [
      0,
      -1,
    ],
    [
      -1,
      -1,
    ],
    [
      -2,
      -1,
    ],
    [
      -3,
      -1,
    ],
    [
      -4,
      -1,
    ],
    [
      -5,
      -1,
    ],
    [
      -6,
      -1,
    ],
    [
      -6,
      -2,
    ],
    [
      -7,
      -2,
    ],
    [
      -8,
      -2,
    ],
    [
      -9,
      -2,
    ],
    [
      -9,
      -1,
    ],
    [
      -9,
      -2,
    ],
    [
      -9,
      -3,
    ],
    [
      -10,
      -3,
    ],
    [
      -9,
      -3,
    ],
    [
      -8,
      -3,
    ],
    [
      -7,
      -3,
    ],
    [
      -7,
      -4,
    ],
    [
      -8,
      -4,
    ],
    [
      -9,
      -4,
    ],
    [
      -9,
      -5,
    ],
    [
      -10,
      -5,
    ],
    [
      -9,
      -5,
    ],
    [
      -9,
      -6,
    ],
    [
      -8,
      -6,
    ],
    [
      -7,
      -6,
    ],
    [
      -7,
      -5,
    ],
    [
      -6,
      -5,
    ],
    [
      -6,
      -4,
    ],
    [
      -5,
      -4,
    ],
    [
      -5,
      -3,
    ],
    [
      -5,
      -2,
    ],
    [
      -4,
      -2,
    ],
    [
      -3,
      -2,
    ],
    [
      -2,
      -2,
    ],
    [
      -1,
      -2,
    ],
    [
      0,
      -2,
    ],
    [
      1,
      -2,
    ],
    [
      2,
      -2,
    ],
    [
      3,
      -2,
    ],
    [
      3,
      -1,
    ],
    [
      4,
      -1,
    ],
    [
      4,
      0,
    ],
    [
      4,
      1,
    ],
    [
      3,
      1,
    ],
    [
      4,
      1,
    ],
    [
      4,
      2,
    ],
    [
      5,
      2,
    ],
    [
      5,
      1,
    ],
    [
      5,
      0,
    ],
    [
      5,
      -1,
    ],
    [
      5,
      -2,
    ],
    [
      4,
      -2,
    ],
    [
      5,
      -2,
    ],
    [
      5,
      -1,
    ],
    [
      5,
      0,
    ],
    [
      5,
      1,
    ],
    [
      5,
      2,
    ],
    [
      4,
      2,
    ],
    [
      4,
      1,
    ],
    [
      3,
      1,
    ],
    [
      4,
      1,
    ],
    [
      4,
      0,
    ],
    [
      4,
      -1,
    ],
    [
      3,
      -1,
    ],
    [
      3,
      -2,
    ],
    [
      3,
      -3,
    ],
    [
      2,
      -3,
    ],
    [
      1,
      -3,
    ],
    [
      1,
      -4,
    ],
    [
      0,
      -4,
    ],
    [
      -1,
      -4,
    ],
    [
      -2,
      -4,
    ],
    [
      -3,
      -4,
    ],
    [
      -4,
      -4,
    ],
    [
      -4,
      -3,
    ],
    [
      -3,
      -3,
    ],
    [
      -2,
      -3,
    ],
    [
      -1,
      -3,
    ],
    [
      -2,
      -3,
    ],
    [
      -3,
      -3,
    ],
    [
      -4,
      -3,
    ],
    [
      -4,
      -4,
    ],
    [
      -3,
      -4,
    ],
    [
      -2,
      -4,
    ],
    [
      -2,
      -5,
    ],
    [
      -2,
      -6,
    ],
    [
      -3,
      -6,
    ],
    [
      -4,
      -6,
    ],
    [
      -5,
      -6,
    ],
    [
      -5,
      -7,
    ],
    [
      -6,
      -7,
    ],
    [
      -6,
      -8,
    ],
    [
      -7,
      -8,
    ],
    [
      -8,
      -8,
    ],
    [
      -8,
      -7,
    ],
    [
      -9,
      -7,
    ],
    [
      -10,
      -7,
    ],
    [
      -10,
      -8,
    ],
    [
      -10,
      -9,
    ],
    [
      -9,
      -9,
    ],
    [
      -8,
      -9,
    ],
    [
      -7,
      -9,
    ],
    [
      -8,
      -9,
    ],
    [
      -9,
      -9,
    ],
    [
      -10,
      -9,
    ],
    [
      -10,
      -8,
    ],
    [
      -10,
      -7,
    ],
    [
      -9,
      -7,
    ],
    [
      -8,
      -7,
    ],
    [
      -8,
      -8,
    ],
    [
      -7,
      -8,
    ],
    [
      -6,
      -8,
    ],
    [
      -5,
      -8,
    ],
    [
      -6,
      -8,
    ],
    [
      -7,
      -8,
    ],
    [
      -8,
      -8,
    ],
    [
      -8,
      -7,
    ],
    [
      -9,
      -7,
    ],
    [
      -10,
      -7,
    ],
    [
      -10,
      -8,
    ],
    [
      -10,
      -9,
    ],
    [
      -9,
      -9,
    ],
    [
      -8,
      -9,
    ],
    [
      -7,
      -9,
    ],
    [
      -8,
      -9,
    ],
    [
      -9,
      -9,
    ],
    [
      -10,
      -9,
    ],
    [
      -10,
      -8,
    ],
    [
      -10,
      -7,
    ],
    [
      -9,
      -7,
    ],
    [
      -8,
      -7,
    ],
    [
      -8,
      -8,
    ],
    [
      -7,
      -8,
    ],
    [
      -6,
      -8,
    ],
    [
      -6,
      -7,
    ],
    [
      -5,
      -7,
    ],
    [
      -4,
      -7,
    ],
    [
      -5,
      -7,
    ],
    [
      -6,
      -7,
    ],
    [
      -6,
      -8,
    ],
    [
      -7,
      -8,
    ],
    [
      -8,
      -8,
    ],
    [
      -8,
      -7,
    ],
    [
      -9,
      -7,
    ],
    [
      -10,
      -7,
    ],
    [
      -10,
      -8,
    ],
    [
      -10,
      -9,
    ],
    [
      -9,
      -9,
    ],
    [
      -8,
      -9,
    ],
    [
      -7,
      -9,
    ],
    [
      -6,
      -9,
    ],
    [
      -6,
      -8,
    ],
    [
      -6,
      -7,
    ],
    [
      -7,
      -7,
    ],
    [
      -6,
      -7,
    ],
    [
      -6,
      -8,
    ],
    [
      -6,
      -9,
    ],
    [
      -7,
      -9,
    ],
    [
      -8,
      -9,
    ],
    [
      -9,
      -9,
    ],
    [
      -10,
      -9,
    ],
    [
      -10,
      -8,
    ],
    [
      -10,
      -7,
    ],
    [
      -9,
      -7,
    ],
    [
      -8,
      -7,
    ],
    [
      -8,
      -8,
    ],
    [
      -7,
      -8,
    ],
    [
      -6,
      -8,
    ],
    [
      -6,
      -7,
    ],
    [
      -5,
      -7,
    ],
    [
      -4,
      -7,
    ],
    [
      -5,
      -7,
    ],
    [
      -5,
      -8,
    ],
    [
      -6,
      -8,
    ],
    [
      -7,
      -8,
    ],
    [
      -8,
      -8,
    ],
    [
      -8,
      -7,
    ],
    [
      -9,
      -7,
    ],
    [
      -10,
      -7,
    ],
    [
      -10,
      -8,
    ],
    [
      -10,
      -9,
    ],
    [
      -9,
      -9,
    ],
    [
      -8,
      -9,
    ],
    [
      -7,
      -9,
    ],
    [
      -6,
      -9,
    ],
    [
      -6,
      -8,
    ],
    [
      -5,
      -8,
    ],
    [
      -4,
      -8,
    ],
    [
      -5,
      -8,
    ],
    [
      -6,
      -8,
    ],
    [
      -6,
      -9,
    ],
    [
      -7,
      -9,
    ],
    [
      -8,
      -9,
    ],
    [
      -9,
      -9,
    ],
    [
      -10,
      -9,
    ],
    [
      -10,
      -8,
    ],
    [
      -10,
      -7,
    ],
    [
      -9,
      -7,
    ],
    [
      -8,
      -7,
    ],
    [
      -8,
      -8,
    ],
    [
      -7,
      -8,
    ],
    [
      -6,
      -8,
    ],
    [
      -6,
      -7,
    ],
    [
      -5,
      -7,
    ],
    [
      -6,
      -7,
    ],
    [
      -7,
      -7,
    ],
    [
      -6,
      -7,
    ],
    [
      -6,
      -8,
    ],
    [
      -6,
      -9,
    ],
    [
      -7,
      -9,
    ],
    [
      -8,
      -9,
    ],
    [
      -9,
      -9,
    ],
    [
      -10,
      -9,
    ],
    [
      -10,
      -8,
    ],
    [
      -10,
      -7,
    ],
    [
      -9,
      -7,
    ],
    [
      -8,
      -7,
    ],
    [
      -8,
      -8,
    ],
    [
      -7,
      -8,
    ],
    [
      -6,
      -8,
    ],
    [
      -6,
      -7,
    ],
    [
      -5,
      -7,
    ],
    [
      -6,
      -7,
    ],
    [
      -6,
      -8,
    ],
    [
      -6,
      -7,
    ],
    [
      -5,
      -7,
    ],
    [
      -5,
      -6,
    ],
    [
      -6,
      -6,
    ],
    [
      -5,
      -6,
    ],
    [
      -5,
      -7,
    ],
    [
      -6,
      -7,
    ],
    [
      -6,
      -8,
    ],
    [
      -7,
      -8,
    ],
    [
      -8,
      -8,
    ],
    [
      -8,
      -7,
    ],
    [
      -9,
      -7,
    ],
    [
      -10,
      -7,
    ],
    [
      -10,
      -8,
    ],
    [
      -10,
      -9,
    ],
    [
      -9,
      -9,
    ],
    [
      -8,
      -9,
    ],
    [
      -7,
      -9,
    ],
    [
      -6,
      -9,
    ],
    [
      -7,
      -9,
    ],
    [
      -7,
      -8,
    ],
    [
      -6,
      -8,
    ],
    [
      -6,
      -9,
    ],
    [
      -5,
      -9,
    ],
    [
      -5,
      -8,
    ],
    [
      -6,
      -8,
    ],
    [
      -7,
      -8,
    ],
    [
      -8,
      -8,
    ],
    [
      -8,
      -7,
    ],
    [
      -9,
      -7,
    ],
    [
      -10,
      -7,
    ],
    [
      -10,
      -8,
    ],
    [
      -10,
      -9,
    ],
    [
      -9,
      -9,
    ],
    [
      -8,
      -9,
    ],
    [
      -7,
      -9,
    ],
    [
      -7,
      -10,
    ],
    [
      -6,
      -10,
    ],
    [
      -5,
      -10,
    ],
    [
      -6,
      -10,
    ],
    [
      -6,
      -11,
    ],
    [
      -7,
      -11,
    ],
    [
      -8,
      -11,
    ],
    [
      -8,
      -12,
    ],
    [
      -8,
      -13,
    ],
    [
      -7,
      -13,
    ],
    [
      -6,
      -13,
    ],
    [
      -6,
      -12,
    ],
    [
      -5,
      -12,
    ],
    [
      -4,
      -12,
    ],
    [
      -4,
      -11,
    ],
    [
      -3,
      -11,
    ],
    [
      -3,
      -10,
    ],
    [
      -2,
      -10,
    ],
    [
      -1,
      -10,
    ],
    [
      0,
      -10,
    ],
    [
      0,
      -9,
    ],
    [
      0,
      -8,
    ],
    [
      -1,
      -8,
    ],
    [
      -2,
      -8,
    ],
    [
      -3,
      -8,
    ],
    [
      -3,
      -7,
    ],
    [
      -2,
      -7,
    ],
    [
      -1,
      -7,
    ],
    [
      -1,
      -6,
    ],
    [
      -1,
      -5,
    ],
    [
      0,
      -5,
    ],
    [
      1,
      -5,
    ],
    [
      2,
      -5,
    ],
    [
      2,
      -4,
    ],
    [
      3,
      -4,
    ],
    [
      4,
      -4,
    ],
    [
      4,
      -3,
    ],
    [
      5,
      -3,
    ],
    [
      6,
      -3,
    ],
    [
      6,
      -2,
    ],
    [
      6,
      -1,
    ],
    [
      6,
      0,
    ],
    [
      7,
      0,
    ],
    [
      7,
      1,
    ],
    [
      7,
      2,
    ],
    [
      6,
      2,
    ],
    [
      7,
      2,
    ],
    [
      7,
      1,
    ],
    [
      7,
      0,
    ],
    [
      6,
      0,
    ],
    [
      6,
      -1,
    ],
    [
      6,
      -2,
    ],
    [
      7,
      -2,
    ],
    [
      7,
      -3,
    ],
    [
      7,
      -4,
    ],
    [
      6,
      -4,
    ],
    [
      6,
      -5,
    ],
    [
      5,
      -5,
    ],
    [
      4,
      -5,
    ],
    [
      3,
      -5,
    ],
    [
      3,
      -6,
    ],
    [
      2,
      -6,
    ],
    [
      1,
      -6,
    ],
    [
      0,
      -6,
    ],
    [
      0,
      -7,
    ],
    [
      1,
      -7,
    ],
    [
      1,
      -8,
    ],
    [
      2,
      -8,
    ],
    [
      3,
      -8,
    ],
    [
      3,
      -7,
    ],
    [
      4,
      -7,
    ],
    [
      4,
      -6,
    ],
    [
      5,
      -6,
    ],
    [
      6,
      -6,
    ],
    [
      7,
      -6,
    ],
    [
      7,
      -5,
    ],
    [
      7,
      -6,
    ],
    [
      6,
      -6,
    ],
    [
      5,
      -6,
    ],
    [
      5,
      -7,
    ],
    [
      5,
      -8,
    ],
    [
      4,
      -8,
    ],
    [
      4,
      -9,
    ],
    [
      3,
      -9,
    ],
    [
      3,
      -10,
    ],
    [
      2,
      -10,
    ],
    [
      1,
      -10,
    ],
    [
      1,
      -11,
    ],
    [
      0,
      -11,
    ],
    [
      0,
      -12,
    ],
    [
      -1,
      -12,
    ],
    [
      -1,
      -13,
    ],
    [
      0,
      -13,
    ],
    [
      -1,
      -13,
    ],
    [
      -1,
      -12,
    ],
    [
      0,
      -12,
    ],
    [
      1,
      -12,
    ],
    [
      2,
      -12,
    ],
    [
      2,
      -11,
    ],
    [
      3,
      -11,
    ],
    [
      4,
      -11,
    ],
    [
      3,
      -11,
    ],
    [
      2,
      -11,
    ],
    [
      2,
      -12,
    ],
    [
      1,
      -12,
    ],
    [
      0,
      -12,
    ],
    [
      -1,
      -12,
    ],
    [
      -1,
      -13,
    ],
    [
      -1,
      -12,
    ],
    [
      0,
      -12,
    ],
    [
      0,
      -11,
    ],
    [
      1,
      -11,
    ],
    [
      1,
      -10,
    ],
    [
      2,
      -10,
    ],
    [
      3,
      -10,
    ],
    [
      3,
      -9,
    ],
  ]

function efficientBacktrackMoves3(path, start, end) {
    try {


        // Find the indices of the start and end positions in the path
        // let startIndex = path.findIndex(p => p[0] === start[0] && p[1] === start[1]);
        // let endIndex = path.findIndex(p => p[0] === end[0] && p[1] === end[1]);
        let startIndex = -1;
        let endIndex = -1;
        for (let i=path.length-1; i>=0; i--) {
            if (startIndex === -1 && path[i][0] === start[0] && path[i][1] === start[1]) {
                startIndex = i;
            } else if (endIndex === -1 && path[i][0] === end[0] && path[i][1] === end[1]) {
                endIndex = i;
            }

            if (startIndex > -1 && endIndex > -1) {
                break;
            }
        }

        // if (startIndex < endIndex) {
        //  	startIndex = path.lastIndexOf(p => p[0] === start[0] && p[1] === start[1]);
        // }

        // If start or end position not found in path, or start comes before end
        if (startIndex === -1 || endIndex === -1 || startIndex < endIndex) {
            return [];
        }

        // Extract the sub-path and remove redundant steps
        let subPath = path.slice(endIndex, startIndex + 1).reverse();
        let optimizedPath = [];
        for (let i = 0; i < subPath.length; i++) {
            // Add the last point without checking
            if (i === subPath.length - 1) {
                optimizedPath.push(subPath[i]);
                break;
            }

            // Check if the next point is in a different direction
            let current = subPath[i];
            let next = subPath[i + 1];
            if (current[0] !== next[0] || current[1] !== next[1]) {
                optimizedPath.push(current);
            }
        }

        // Generate moves by backtracking from start to end
        let moves = [];
        for (let i = 0; i < optimizedPath.length - 1; i++) {
            let fromPos = optimizedPath[i];
            let toPos = optimizedPath[i + 1];
            let xDiff = toPos[0] - fromPos[0];
            let yDiff = toPos[1] - fromPos[1];

            if (xDiff > 0) {
                moves.push('right');
            } else if (xDiff < 0) {
                moves.push('left');
            }

            if (yDiff > 0) {
                moves.push('up');
            } else if (yDiff < 0) {
                moves.push('down');
            }
        }

        let fixedMoves = [];
        for (let i = 0; i < moves.length - 1; i++) {
            switch (moves[i]) {
                case 'up':
                    if (moves[i + 1] === 'down') {
                        i++;
                    } else {
                        fixedMoves.push(moves[i]);
                    }
                    break;
                case 'down':
                    if (moves[i + 1] === 'up') {
                        i++;
                    } else {
                        fixedMoves.push(moves[i]);
                    }
                    break;
                case 'left':
                    if (moves[i + 1] === 'right') {
                        i++;
                    } else {
                        fixedMoves.push(moves[i]);
                    }
                    break;
                case 'right':
                    if (moves[i + 1] === 'left') {
                        i++;
                    } else {
                        fixedMoves.push(moves[i]);
                    }
                    break;
                default:
                    break;
            }
        }

        //append the last move, since it doesn't get processed by the previopus loop bc its checking i+1
        fixedMoves.push(moves[moves.length - 1]);

        return fixedMoves;

    } catch (e) {
        console.log(e);
        return [];
    }
}

function efficientBacktrackMoves2(path, start, end) {
    try {


        // Find the indices of the start and end positions in the path
        let startIndex = path.findIndex(p => p[0] === start[0] && p[1] === start[1]);
        let endIndex = path.findIndex(p => p[0] === end[0] && p[1] === end[1]);

        // if (startIndex < endIndex) {
        //  	startIndex = path.lastIndexOf(p => p[0] === start[0] && p[1] === start[1]);
        // }

        // If start or end position not found in path, or start comes before end
        // if (startIndex === -1 || endIndex === -1 || startIndex < endIndex) {
        if (startIndex === -1 || endIndex === -1) {

            return [];
        }

        // Extract the sub-path and remove redundant steps
        let subPath = path.slice(endIndex, startIndex + 1).reverse();
        let optimizedPath = [];
        for (let i = 0; i < subPath.length; i++) {
            // Add the last point without checking
            if (i === subPath.length - 1) {
                optimizedPath.push(subPath[i]);
                break;
            }

            // Check if the next point is in a different direction
            let current = subPath[i];
            let next = subPath[i + 1];
            if (current[0] !== next[0] || current[1] !== next[1]) {
                optimizedPath.push(current);
            }
        }

        // Generate moves by backtracking from start to end
        let moves = [];
        for (let i = 0; i < optimizedPath.length - 1; i++) {
            let fromPos = optimizedPath[i];
            let toPos = optimizedPath[i + 1];
            let xDiff = toPos[0] - fromPos[0];
            let yDiff = toPos[1] - fromPos[1];

            if (xDiff > 0) {
                moves.push('right');
            } else if (xDiff < 0) {
                moves.push('left');
            }

            if (yDiff > 0) {
                moves.push('up');
            } else if (yDiff < 0) {
                moves.push('down');
            }
        }

        let fixedMoves = [];
        for (let i = 0; i < moves.length - 1; i++) {
            switch (moves[i]) {
                case 'up':
                    if (moves[i + 1] === 'down') {
                        i++;
                    } else {
                        fixedMoves.push(moves[i]);
                    }
                    break;
                case 'down':
                    if (moves[i + 1] === 'up') {
                        i++;
                    } else {
                        fixedMoves.push(moves[i]);
                    }
                    break;
                case 'left':
                    if (moves[i + 1] === 'right') {
                        i++;
                    } else {
                        fixedMoves.push(moves[i]);
                    }
                    break;
                case 'right':
                    if (moves[i + 1] === 'left') {
                        i++;
                    } else {
                        fixedMoves.push(moves[i]);
                    }
                    break;
                default:
                    break;
            }
        }

        //append the last move, since it doesn't get processed by the previopus loop bc its checking i+1
        fixedMoves.push(moves[moves.length - 1]);

        return fixedMoves;

    } catch (e) {
        console.log(e);
        return [];
    }
}


// let path = [[0, 0], [1, 0], [2, 0], [3, 0], [3, 1], [3, 2], [2, 2], [2, 1], [2, 2]];

let start = [3,-9];
let destination = [4,-11];

let moves = efficientBacktrackMoves3(path, start, destination);
console.log(moves);
